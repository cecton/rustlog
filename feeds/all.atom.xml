<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Rustlog</title><link href="https://lifthrasiir.github.io/rustlog/" rel="alternate"></link><link href="https://lifthrasiir.github.io/rustlog/feeds/all.atom.xml" rel="self"></link><id>https://lifthrasiir.github.io/rustlog/</id><updated>2015-01-11T03:51:00+09:00</updated><entry><title>Worklog 2015-01-10</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2015-01-10.html" rel="alternate"></link><updated>2015-01-11T03:51:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2015-01-11:rustlog/worklog-2015-01-10.html</id><summary type="html">&lt;p&gt;Okay, I was so frantic about the language updates and
went to (mostly) the library maintenance mode.
If you saw &lt;code&gt;encoding&lt;/code&gt; or &lt;code&gt;chrono&lt;/code&gt; from &lt;a href="https://crates.io/"&gt;crates.io&lt;/a&gt; a lot,
that's because I tended to update per &lt;em&gt;each&lt;/em&gt; breaking nightly.&lt;/p&gt;
&lt;p&gt;Anyways, we've finally got &lt;a href="http://blog.rust-lang.org/2015/01/09/Rust-1.0-alpha.html"&gt;1.0.0 alpha&lt;/a&gt; and
I can finally refrain from simply keeping libraries up.
I'm now working on Chrono 0.2, which will have a new &lt;code&gt;Offset&lt;/code&gt; design.&lt;/p&gt;
&lt;h2&gt;Grisu and rust-strconv&lt;/h2&gt;
&lt;p&gt;By the way, what happened to &lt;a href="https://github.com/lifthrasiir/rust-strconv/"&gt;rust-strconv&lt;/a&gt;?
In the previous (i.e. 3 week old) post
I've said the initial version of Grisu can be released within a week.
That was a serious misprediction and it actually took &lt;a href="https://github.com/lifthrasiir/rust-strconv/commit/81e4f157b90191ef335c2ad692e7ebd34221a367"&gt;two full weeks&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Grisu by itself is a simple algorithm to understand.
It first scales the input into a certain convenient range
(while keeping the exponent, obviously),
so that the range can be easily fit to &lt;code&gt;u64&lt;/code&gt;.
It then maintains two approximate ranges
for the actual range in which values would round to that number;
one overestimates, another underestimates.
Quoting the diagram in the comments:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;        +- actual range of minus
  | &amp;lt;---|---------------------- unsafe region --------------------------&amp;gt; |
  |     |                                                                 |
  |  |&amp;lt;---&amp;gt;|  | &amp;lt;--------------- safe region ---------------&amp;gt; |           |
  |  |     |  |                                               |           |
  |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|
  |&amp;lt;---&amp;gt;|&amp;lt;---&amp;gt;|                 |&amp;lt;---&amp;gt;|&amp;lt;---&amp;gt;|                 |&amp;lt;---&amp;gt;|&amp;lt;---&amp;gt;|
  |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|
  |   minus   |                 |     v     |                 |   plus    |
minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Both the scaled value and ranges are repeatedly narrowed down
until we are out of significant digits.
(There is one important inequality proved in the paper
which can be used to quickly test this.)
At this stage we have &lt;em&gt;one&lt;/em&gt; possible shortest representation,
so we try other representations to find the shortest representation
which is also closest to the actual value.
Finally, we can verify that it actually is in the underestimated range
so we can safely return it.
Each step has its own rounding error,
but it is well characterized so we account for that.&lt;/p&gt;
&lt;p&gt;The problem with implementing Grisu is not the complexity;
it's rather an analysis, which is very unwieldy to understand.
For example, the implementation shouldn't overflow,
and Grisu code actively avoids that,
but both the paper and the &lt;a href="https://github.com/v8/v8-git-mirror/blob/master/src/fast-dtoa.cc"&gt;code&lt;/a&gt; is shallow in details.
The code has an extensive documentation, but not a proof,
and it is very hard to be sure on edge cases.
At the end, it took almost a month to fully understand and write
&lt;a href="https://github.com/lifthrasiir/rust-strconv/blob/5cbbb53/src/flt2dec/strategy/grisu.rs#L212-L476"&gt;every required constraint&lt;/a&gt; in implementations down.
Frankly speaking, my comments wouldn't really help anyway
if you are to write your own reimplementation of Grisu,
but at least it should guide potential reviewers.&lt;/p&gt;
&lt;p&gt;Fortunately, my attempt has paid off.
Combined with Dragon it swiftly overshadows the original naive implementation
both in the performance (up to 1000x faster) and the accuracy.
I've exhaustively verified that
Grisu for &lt;code&gt;f32&lt;/code&gt; returns the same result as Dragon when it does give a result.
Just out of curiosity, I've also counted how many &lt;code&gt;f32&lt;/code&gt; does return &lt;code&gt;None&lt;/code&gt;;
there are precisely 17,763,160 such values out of 2,121,451,879 finite values.
I have some idea for improving on severe cases &lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;
but that would be another story.&lt;/p&gt;
&lt;p&gt;There are two more possible modes of floating point printing.
Grisu-like algorithm can be used to quickly try to print
a predefined number of significant digits
or up to certain number of digits after a decimal point if possible.
I have a working code to do the former (with an informal proof in progress),
but it seems not to fit well to the common interface shared by Dragon.
The common interface can notify that the following digits are zeroes,
but it is not very obvious that Grisu can report &lt;code&gt;None&lt;/code&gt; in that case.
(Grisu cannot really give the exact answer in this case.)
I'm currently studying the C implementation for possible resolution.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;In the worst case, 50% of 2^23 &lt;code&gt;f32&lt;/code&gt; values between 2^21 and 2^22
  return &lt;code&gt;None&lt;/code&gt; (it's 0.8% in the full range, for comparison).
  This is mostly because Grisu's inability to handle
  the exact halfway cases very common to that range.
  Note that this range is relatively close to 1 (than many others),
  so it can impact the real world performance of Grisu.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary></entry><entry><title>Worklog 2014-12-20</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2014-12-20.html" rel="alternate"></link><updated>2014-12-21T00:01:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-21:rustlog/worklog-2014-12-20.html</id><summary type="html">&lt;p&gt;This week we saw another series of breakages via the macro syntax reform. :)
I still didn't have much time to keep up,
so I mostly did the minimal maintenance work,
but still there are some significant tasks I've done this week:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/lifthrasiir/rust-encoding/commit/1803d8a7a7e442af2ecc7ea3a3cc419562a0276a"&gt;Encoding 0.2.8&lt;/a&gt; has been released.
  This is a significant, non-language-change fix due to
  the recent change to the Encoding specification.
  I've found a &lt;a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=27675"&gt;spec bug&lt;/a&gt; while working on that.&lt;/li&gt;
&lt;li&gt;I've written a small &lt;a href="https://github.com/rust-lang/rfcs/pull/532"&gt;RFC&lt;/a&gt; for
  changing the &lt;code&gt;mod&lt;/code&gt; keyword in &lt;code&gt;use&lt;/code&gt; to the &lt;code&gt;self&lt;/code&gt; keyword.
  This is my first RFC ever, so I'm glad the writing seems fine enough.&lt;/li&gt;
&lt;li&gt;I worked on the floating-point printing code of &lt;a href="https://github.com/lifthrasiir/rust-strconv"&gt;rust-strconv&lt;/a&gt;
  during the Korean Rust meetup today.
  I think I can release the initial version this week.&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>Worklog 2014-12-13</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2014-12-13.html" rel="alternate"></link><updated>2014-12-13T23:59:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-13:rustlog/worklog-2014-12-13.html</id><summary type="html">&lt;p&gt;Due to the personal concerns I haven't do much things, but at least...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I've updated &lt;a href="https://github.com/lifthrasiir/rust-encoding/"&gt;rust-encoding&lt;/a&gt; and &lt;a href="https://github.com/lifthrasiir/rust-chrono"&gt;rust-chrono&lt;/a&gt; for opt-in &lt;code&gt;Copy&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;I've pushed a small &lt;a href="https://github.com/rust-lang/rust/issues/19719"&gt;fix&lt;/a&gt; for &lt;a href="https://github.com/rust-lang/rust/pull/19764"&gt;#19764&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I... think I've opened two issues (&lt;a href="https://github.com/rust-lang/rust/issues/19723"&gt;#19723&lt;/a&gt; and &lt;a href="https://github.com/rust-lang/rust/issues/19762"&gt;#19762&lt;/a&gt;) and
  started to work on the former. Not much, though.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unfortunately I didn't have spare time for working on &lt;a href="https://github.com/rust-lang/rust/pull/19606"&gt;#19606&lt;/a&gt;.
Maybe for the next week.&lt;/p&gt;</summary></entry><entry><title>Worklog 2014-12-09</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2014-12-09.html" rel="alternate"></link><updated>2014-12-10T00:17:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-10:rustlog/worklog-2014-12-09.html</id><summary type="html">&lt;p&gt;Okay, I've released &lt;a href="https://github.com/lifthrasiir/rust-soundchange"&gt;rust-soundchange&lt;/a&gt; with a basic documentation and tests.
I've also pushed a &lt;a href="https://github.com/P1start/an-rs/pull/1"&gt;pull request&lt;/a&gt; to P1start's &lt;code&gt;an-rs&lt;/code&gt;,
let's see if it really is accepted :)&lt;/p&gt;
&lt;h2&gt;Notes on &lt;code&gt;english.sc&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://zompist.com/spell.html"&gt;Mark Rosenfelder's article&lt;/a&gt; links to a computerized rule file,
which I've used as a basis of rust-soundchange rules.
After some debugging, however, I found that the following rule is incorrect:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Incorrect&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="sr"&gt;/@/&lt;/span&gt;&lt;span class="n"&gt;VC&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;_l&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;
&lt;span class="n"&gt;Correct&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="sr"&gt;/@/&lt;/span&gt;&lt;span class="n"&gt;VC&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;_l&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This particular rule corresponds to the rule 38,
i.e. any vowel reduces to a schwa (&lt;code&gt;@&lt;/code&gt;) before final &lt;code&gt;l&lt;/code&gt; (as in &lt;code&gt;final&lt;/code&gt;),
but only when it is not the only vowel in that word and
&lt;em&gt;its sound value has been assigned by prior rules&lt;/em&gt;.
The original rule has incorrectly used an "any vowel" (&lt;code&gt;V&lt;/code&gt;) variable
in place of an "any &lt;em&gt;untranslated&lt;/em&gt; vowel" (&lt;code&gt;U&lt;/code&gt;) variable.&lt;/p&gt;
&lt;p&gt;It seems that &lt;code&gt;english.out&lt;/code&gt; itself is generated via the fixed rules
(and with this fix my implementation produces 100% exact output for this set)
but Rosenfelder forgot to update &lt;code&gt;english.sc&lt;/code&gt;. Oops.&lt;/p&gt;</summary></entry><entry><title>Worklog 2014-12-08</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2014-12-08.html" rel="alternate"></link><updated>2014-12-09T02:51:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-09:rustlog/worklog-2014-12-08.html</id><summary type="html">&lt;p&gt;After some wrestling with rustc, I've taken some refresh.
I had a grand^Wstupid plan for improving &lt;a href="https://crates.io/crates/an"&gt;an&lt;/a&gt;,
by implementing a better spell-to-pronounciation algorithm and
using that to determine if the word starts with a vowel or not.
(Mostly for fun, but I also wanted to make some useful utility.)
I've now implemented an entirety of &lt;a href="http://zompist.com/spell.html"&gt;Mark Rosenfelder's algorithm&lt;/a&gt;
which has some test code like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;assert_eq&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spell_to_sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;coffee&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_slice&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;kòfë&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;assert_eq&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spell_to_sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;market&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_slice&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;môrkêt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;assert_eq&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spell_to_sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ugly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_slice&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ûglë&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;assert_eq&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spell_to_sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;high&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_slice&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hï&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;assert_eq&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;spell_to_sound&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;canal&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;as_slice&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;känâl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;...Well, it still fails for some dozens of cases but it looks nice.
(Here I really mean that this doesn't exactly match the known output of the algorithm.
Since the algorithm itself is approximate,
if the bug actually &lt;em&gt;improves&lt;/em&gt; the error rate, I might leave it as is.)&lt;/p&gt;</summary></entry><entry><title>Worklog 2014-12-06</title><link href="https://lifthrasiir.github.io/rustlog/worklog-2014-12-06.html" rel="alternate"></link><updated>2014-12-07T13:09:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-07:rustlog/worklog-2014-12-06.html</id><summary type="html">&lt;p&gt;I was continously working on &lt;a href="https://github.com/rust-lang/rust/issues/15309"&gt;#15309&lt;/a&gt;.
Basically, Rustdoc has a link to the source code and
&lt;em&gt;some&lt;/em&gt; items have gotten their links incorrect.
This is proved quite hard to solve, as I've outlined the cause,
and I'm still figuring out how to solve that.&lt;/p&gt;
&lt;h2&gt;Wonderful world of metadata&lt;/h2&gt;
&lt;p&gt;It is a relatively hidden piece of the fact in Rust,
but Rust compiler utilizes a &lt;em&gt;metadata&lt;/em&gt;
to track almost every information across multiple crates.&lt;/p&gt;
&lt;p&gt;In fact, it is not hard to see the metadata's very existence.
The metadata occupies a custom section in the excutable files or
a self-explanatory file name &lt;code&gt;rust.metadata.bin&lt;/code&gt; in rlibs.
Any standard utilities on those files can be used to see them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;readelf /usr/local/rust/lib/libstd-4e7c5e5c.so -S &lt;span class="p"&gt;|&lt;/span&gt; grep rustc -A1
  &lt;span class="o"&gt;[&lt;/span&gt;25&lt;span class="o"&gt;]&lt;/span&gt; .note.rustc       NOTE             00000000002ebaf0  000ebaf0
       00000000001da82a  &lt;span class="m"&gt;0000000000000000&lt;/span&gt;  WA       &lt;span class="m"&gt;0&lt;/span&gt;     &lt;span class="m"&gt;0&lt;/span&gt;     16
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that the metadata can be very huge.
In this case, the section size is &lt;code&gt;0x1da82a&lt;/code&gt; bytes, i.e. about 1.9 megs.
How much is that? It's over 60% of the entire executable if you ask that.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ls -al /usr/local/rust/lib/libstd-4e7c5e5c.so
-rw-r--r-- &lt;span class="m"&gt;1&lt;/span&gt; arachneng &lt;span class="m"&gt;3197472&lt;/span&gt; Dec  &lt;span class="m"&gt;5&lt;/span&gt; 22:00 /usr/local/rust/lib/libstd-4e7c5e5c.so
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Typical C/C++ compilers work on the simplitistic assumption,
namely, they can &lt;em&gt;mangle&lt;/em&gt; names to avoid any problem.
So when you have a function named &lt;code&gt;f&lt;/code&gt; with no argument and no return type,
its name is (say) mangled into &lt;code&gt;_Z1fv&lt;/code&gt; in some compilers and
&lt;code&gt;?f@@YAXXZ&lt;/code&gt; in other compilers, so that they cannot be linked against each other.
Some compilers (notably G++) explicitly require that
there is some &lt;em&gt;dummy&lt;/em&gt; symbol like &lt;code&gt;__gxx_personality_v0&lt;/code&gt;
and otherwise the link fails.&lt;/p&gt;
&lt;p&gt;This &lt;a href="https://en.wikipedia.org/wiki/Name_mangling"&gt;name mangling&lt;/a&gt; is actually a good practice.
Different compilers commonly have different ABIs (Application Binary Interfaces),
so mixing different ABIs in the same executable should be avoided.
Many ABIs actually seem to be compatible but they often differ in details.&lt;/p&gt;
&lt;p&gt;The problem is that, the name mangling gives too little information.
If you have a linker error, well, you have a variety of options to try.
You may have tried to link from G++ to VC++.
You may have your function name incorrect.
You may have... an extra &lt;code&gt;namespace&lt;/code&gt;. (Namespaces surely affect the name mangling.)
You may have some other type incorrect, on which your function depends.
Perhaps, you shouldn't link to that function at all, since it's a template.&lt;/p&gt;
&lt;p&gt;The metadata is a good complement to the name mangling.
It has every type information to the public items,
and (in the case of Rust) every trait implementation available.
If the item has to be inlined (or generic), the &lt;em&gt;contents&lt;/em&gt; of the item is
also available to the metadata so that
the compiler can inline its definition out of the original crate.&lt;/p&gt;
&lt;p&gt;And at the expense of this improvement,
the metadata structure is &lt;em&gt;damn&lt;/em&gt; complex and the client code can go wrong.&lt;/p&gt;
&lt;h2&gt;Identifying Definitions&lt;/h2&gt;
&lt;p&gt;It seems that the metadata is nothing to do with the documentation.
Unfortunately, #15309 is an example that the metadata is indeed important:
it is hard to identify definitions across multiple crates.&lt;/p&gt;
&lt;p&gt;Consider one example.
The trait &lt;code&gt;UnicodeChar&lt;/code&gt; is actually available in three places:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unicode::u_char::UnicodeChar&lt;/code&gt; (private)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unicode::char::UnicodeChar&lt;/code&gt; (reexported, public)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::char::UnicodeChar&lt;/code&gt; (reexported again, public)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since Rustdoc strips the private items,
the primary documentation is available as &lt;code&gt;unicode::char::UnicodeChar&lt;/code&gt;.
Now, how does Rustdoc know of this reexport when generating the docs for &lt;code&gt;std&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Incredibly the answer is &lt;em&gt;no&lt;/em&gt;―Rustdoc doesn't know about the reexports!
What it actually does is to simply link to the original definition and
hope it correctly redirects to the inlined reexports.
Sounds risky, huh? But this is &lt;a href="https://github.com/rust-lang/rust/blob/a31ad6b/src/librustdoc/html/render.rs#L104-L107"&gt;what Rustdoc actually handles reexports&lt;/a&gt;.
When Rustdoc has enough information to generate redirect pages(*), it will do;
Otherwise it will use those redirect pages.&lt;/p&gt;
&lt;p&gt;(*) I should mention that the metadata obviously contains the reexports.
Still, Rustdoc only sees the original items precisely because
the metadata decoder doesn't directly show the links from the reexport to the item.
And the original items contain, alas, a path to the original items and not reexports.&lt;/p&gt;
&lt;p&gt;Links to the source code pose another problem.
The compiled crate itself doesn't have the source code, quite reasonably.
In this matter, Rustdoc again relies on the prior incarnation of itself
to generate suitable redirects.
Now say that we have implemented &lt;a href="https://github.com/rust-lang/rust/issues/12932"&gt;#12932&lt;/a&gt;
and we have multiple source links in the single documentation page.
How would you do identify the correct link to redirect?&lt;/p&gt;
&lt;p&gt;The original code was using a unique identifier to each definition,
generated shortly before the analysis phase ("phase 3").
This is called a &lt;code&gt;NodeId&lt;/code&gt; (or its cross-crate version, &lt;code&gt;DefId&lt;/code&gt;)
and Rustdoc-generated pages will check if
the &lt;code&gt;gotosrc&lt;/code&gt; parameter contains a matching &lt;code&gt;NodeId&lt;/code&gt; to redirect.
This should have been correct unless the following were correct:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;NodeId&lt;/code&gt;s change when you change the source code.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Well, this is primarily because &lt;code&gt;NodeId&lt;/code&gt;s are used to identify a part of
abstract syntax tree (AST).
This is also why one cannot (normally) link to a recompiled crate (yet);
the stable ABI would be awesome but it's a huge undertaking.&lt;/p&gt;
&lt;p&gt;It seemed that #15309 only appears in the &lt;code&gt;alloc&lt;/code&gt; crate.
Ultimately this was because, &lt;code&gt;rustc&lt;/code&gt; sees &lt;code&gt;--cfg jemalloc&lt;/code&gt; but not &lt;code&gt;rustdoc&lt;/code&gt; doesn't.
This small option mostly affects the &lt;code&gt;alloc&lt;/code&gt; crate,
causing &lt;code&gt;DefId&lt;/code&gt;s change.&lt;/p&gt;
&lt;p&gt;Personally I learned lots about the metadata over the course of debugging,
but only after I gave up and tried to make a &lt;a href="https://gist.github.com/lifthrasiir/7fb50a52154ffc8c0b5e"&gt;custom metadata decoder&lt;/a&gt; in Python.
Then I realized that the metadata in question had a skewed &lt;code&gt;DefId&lt;/code&gt; and
instantly looked at the Makefile. Dang.
I really hope to see a proper analysis tool (&lt;a href="https://github.com/rust-lang/rust/issues/6912"&gt;#6912&lt;/a&gt;) for the metadata.&lt;/p&gt;
&lt;h2&gt;Possible Solutions&lt;/h2&gt;
&lt;p&gt;It's indeed hard to identify definitions across multiple crates!
We don't have a definite solution, and can only outline general directions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Rustdoc should not identify definitions via a &lt;code&gt;DefId&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Rustdoc should be able to generate documentations from the compiled crate.
   (This is what &lt;a href="#19606"&gt;I'm currently working on&lt;/a&gt;.)&lt;/li&gt;
&lt;li&gt;In general, the metadata should have a good notion
   to uniquely identify the definition independently of the source code change.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Phew! This post went too far than I first imagined. Hope you enjoyed this.&lt;/p&gt;</summary></entry><entry><title>The Beginning</title><link href="https://lifthrasiir.github.io/rustlog/the-beginning.html" rel="alternate"></link><updated>2014-12-06T18:48:00+09:00</updated><author><name>Kang Seonghoon</name></author><id>tag:lifthrasiir.github.io,2014-12-06:rustlog/the-beginning.html</id><summary type="html">&lt;p&gt;Hello, and welcome to the first post to the Rustlog!&lt;/p&gt;
&lt;p&gt;For everyone &lt;em&gt;not&lt;/em&gt; interested about the author:
I'm &lt;a href="http://mearie.org/about/kang-seonghoon.en"&gt;Kang Seonghoon&lt;/a&gt;, a Korean software developer doing funky things.
In the world of Rust I'm probably best known for
&lt;a href="https://github.com/lifthrasiir/rust-encoding"&gt;rust-encoding&lt;/a&gt;, a comprehensive character encoding library.
I also happen to enjoy talking on Moznet #rust (as known as &lt;code&gt;Yurume&lt;/code&gt;).&lt;/p&gt;
&lt;h2&gt;So what the hell is this blog?&lt;/h2&gt;
&lt;p&gt;I have a separate personal &lt;a href="http://j.mearie.org/"&gt;journal&lt;/a&gt; in my website.
Probably many of you wouldn't understand its contents;
it's almost Korean only, and even though I've done some works to
make the &lt;em&gt;whole&lt;/em&gt; website bilingual,
the journal remains quite exclusive in Korean.
(I do have some &lt;a href="http://j.mearie.org/tagged/english"&gt;English posts&lt;/a&gt; though.)&lt;/p&gt;
&lt;p&gt;Still, I have a desire to write useful posts in English.
That's why I sometimes write to &lt;a href="https://gist.github.com/lifthrasiir/"&gt;Gist&lt;/a&gt;.
It is technically not a blog, but at least it is a comfortable place
to write a Markdown post.
I also have been motivated by the concept of "worklog"
as a daily diary for logging the day's work.&lt;/p&gt;
&lt;p&gt;So I'm going to give a shot.
&lt;strong&gt;Every Rust-related post in English from now on will go here.
Also, I'll try to write a short remainder about
whatever I've done with Rust every day ("worklog").&lt;/strong&gt;
I know this is very hard from the experience,
but at least I'll try to do so.
I'm kind of a yak-shaving personnel,
but this time I chose to stick to &lt;a href="http://getpelican.com/"&gt;Pelican&lt;/a&gt;
as it seems easy to install and &lt;em&gt;forget&lt;/em&gt; about it.&lt;/p&gt;
&lt;p&gt;I'd appreciate any feedback on the post available here,
but unless there is a link to the explicit feedback form,
please direct any feedback to my &lt;a href="http://mearie.org/about/contact.en"&gt;personal email&lt;/a&gt;.
I'm close to &lt;em&gt;hate&lt;/em&gt; the direct comments, so sorry about that.
And obviously my writing solely represents my own opinion
and not my employer's or organization's. :)&lt;/p&gt;</summary></entry></feed>